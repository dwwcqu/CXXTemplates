# 7. 通过值还是引用？

自从 C++ 诞生以来，它就提供了按值传递和按引用传递两种方式，但选择哪种方式并不总是容易的：通常，对于非简单对象，按引用传递成本较低，但也更复杂。C++11 引入了移动语义，这意味着我们现在有不同的方式来**按引用传递参数**[^1]：

1. `X const&`（常量左值引用）：参数引用传递的对象，但无法修改它。
2. `X&`（非常量左值引用）：参数引用传递的对象，可以修改它。
3. `X&&`（右值引用）：参数引用传递的对象，并支持移动语义，这意味着可以修改或“窃取”其值。

对于已知的具体类型，如何声明参数已经相当复杂。而在模板中，类型未知，因此决定使用哪种传递机制就更加困难了。

尽管如此，我们在[第 1.6.1 节](./ch1.md/#161-按值传递还是按引用传递)中建议，除非有充分理由（如以下情况），否则应在函数模板中按值传递参数：

- 无法复制[^2]；
- 参数用于返回数据；
- 模板只是将参数转发到其他地方，同时保留原始参数的所有属性；
- 有显著的性能提升；

本章讨论了在模板中声明参数的不同方法，并阐述了推荐使用按值传递的一般理由，同时也提供了不这样做的理由。本章还探讨了在处理字符串字面量和其他原始数组时遇到的棘手问题。阅读本章时，熟悉值类别（左值、右值、纯右值、过期值等）的术语会有所帮助，这些术语在附录 B 中进行了说明。

[^1]: 常量右值引用（`X const&&`）也是可能的，但目前它没有确立的语义意义。

[^2]: 请注意，从 C++17 开始，即使没有可用的复制或移动构造函数，也可以通过值传递临时实体（右值）。因此，从 C++17 开始，额外的限制是左值无法复制。

## 7.1. 按值传递

当按值传递参数时，每个参数原则上都必须被复制。因此，每个参数都成为传递对象的副本。对于类，副本通常由复制构造函数初始化。

调用复制构造函数可能会很昂贵。然而，即使按值传递参数，也有多种方法可以避免昂贵的复制操作。事实上，编译器可能会优化掉复制操作，即使对于复杂的对象，使用移动语义也可以使复制变得廉价。

例如，来看一个简单的函数模板，它的参数是按值传递的：

```cpp
template<typename T>
void printV(T arg) {
    ...
}
```

当为整数调用此函数模板时，生成的代码为：

```cpp
void printV(int arg) {
    ...
}
```

参数 `arg` 成为传递参数的副本，无论是对象、字面值还是函数返回的值。

如果我们定义一个 `std::string` 并为其调用此函数模板：

```cpp
std::string s = "hi";
printV(s);
```

模板参数 `T` 实例化为 `std::string`，因此我们得到：

```cpp
void printV(std::string arg) {
    ...
}
```

再次说明，当传递字符串时，`arg` 成为 `s` 的副本。这次副本是通过字符串类的复制构造函数创建的，这可能是一个昂贵的操作，因为原则上此复制操作会创建一个完整或“深拷贝”，即副本在内部分配自己的内存以保存值。

然而，并不总是会调用复制构造函数。考虑以下情况：

```cpp
std::string returnString();
std::string s = "hi";
printV(s); // 复制构造函数
printV(std::string("hi")); // 通常优化掉了复制（否则使用移动构造函数）
printV(returnString()); // 通常优化掉了复制（否则使用移动构造函数）
printV(std::move(s)); // 移动构造函数
```

在第一个调用中，我们传递了一个左值（lvalue），这意味着使用了复制构造函数。然而，在第二个和第三个调用中，当直接为 prvalue（临时对象，或由其他函数返回的值；详见附录 B）调用函数模板时，编译器通常会优化参数传递，使得根本不会调用复制构造函数。注意，从 C++17 开始，此优化是强制要求的。在 C++17 之前，如果编译器没有优化掉复制操作，至少必须尝试使用移动语义，这通常使复制操作变得廉价。在最后一个调用中，我们传递了一个 xvalue（通过 `std::move()` 转换的现有非常量对象），通过这种方式，我们强制调用移动构造函数，表示我们不再需要 `s` 的值。

因此，当参数按值传递时，调用 `printV()` 实现通常只在传递左值时代价较高（即我们之前创建并通常还会继续使用的对象，因为我们没有使用 `std::move()` 来传递它）。不幸的是，这是一个相当常见的情况。一个原因是我们通常会早些创建对象，然后在稍后（经过一些修改后）传递给其他函数。